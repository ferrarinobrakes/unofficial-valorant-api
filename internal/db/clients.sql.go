// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: clients.sql

package db

import (
	"context"
)

const cleanStaleClients = `-- name: CleanStaleClients :exec
DELETE FROM clients
WHERE last_heartbeat < datetime('now', '-2 minutes')
`

func (q *Queries) CleanStaleClients(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanStaleClients)
	return err
}

const getAllClients = `-- name: GetAllClients :many
SELECT client_id, last_heartbeat, lcu_available, connected_at, version FROM clients
ORDER BY last_heartbeat DESC
`

func (q *Queries) GetAllClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, getAllClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ClientID,
			&i.LastHeartbeat,
			&i.LcuAvailable,
			&i.ConnectedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailableClients = `-- name: GetAvailableClients :many
SELECT client_id, last_heartbeat, lcu_available, connected_at, version FROM clients
WHERE lcu_available = TRUE
  AND last_heartbeat > datetime('now', '-30 seconds')
ORDER BY last_heartbeat DESC
`

func (q *Queries) GetAvailableClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.QueryContext(ctx, getAvailableClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ClientID,
			&i.LastHeartbeat,
			&i.LcuAvailable,
			&i.ConnectedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const registerClient = `-- name: RegisterClient :exec
INSERT INTO clients (client_id, version, last_heartbeat, lcu_available, connected_at)
VALUES (?, ?, CURRENT_TIMESTAMP, ?, CURRENT_TIMESTAMP)
ON CONFLICT(client_id) DO UPDATE SET
    version = excluded.version,
    last_heartbeat = CURRENT_TIMESTAMP,
    lcu_available = excluded.lcu_available,
    connected_at = CURRENT_TIMESTAMP
`

type RegisterClientParams struct {
	ClientID     string `json:"client_id"`
	Version      string `json:"version"`
	LcuAvailable bool   `json:"lcu_available"`
}

func (q *Queries) RegisterClient(ctx context.Context, arg RegisterClientParams) error {
	_, err := q.db.ExecContext(ctx, registerClient, arg.ClientID, arg.Version, arg.LcuAvailable)
	return err
}

const removeClient = `-- name: RemoveClient :exec
DELETE FROM clients
WHERE client_id = ?
`

func (q *Queries) RemoveClient(ctx context.Context, clientID string) error {
	_, err := q.db.ExecContext(ctx, removeClient, clientID)
	return err
}

const updateClientHeartbeat = `-- name: UpdateClientHeartbeat :exec
UPDATE clients
SET last_heartbeat = CURRENT_TIMESTAMP,
    lcu_available = ?
WHERE client_id = ?
`

type UpdateClientHeartbeatParams struct {
	LcuAvailable bool   `json:"lcu_available"`
	ClientID     string `json:"client_id"`
}

func (q *Queries) UpdateClientHeartbeat(ctx context.Context, arg UpdateClientHeartbeatParams) error {
	_, err := q.db.ExecContext(ctx, updateClientHeartbeat, arg.LcuAvailable, arg.ClientID)
	return err
}
